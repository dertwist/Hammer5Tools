"""
CS2RemoteConsole PTY Controller

Manages communication with CS2 via CS2RemoteConsole-client.exe using a PTY (pseudo-terminal).
Handles command sequencing, output parsing, and connection lifecycle.

Strips ANSI escape codes (colors, cursor movements) from TUI output for readability.
"""
import os
import time
import re
import winpty
import subprocess
from pathlib import Path
from typing import Optional, Callable

# Regex to remove ANSI escape sequences (CSI codes like \x1b[31m and simple ones like \x1b7)
ANSI_ESCAPE = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~]|[78])')



class CS2RemoteConsoleController:
    """
    Wraps CS2RemoteConsole-client.exe in a PTY for reliable command automation.
    
    Strips ANSI escape codes from TUI output for clean, readable logs.
    
    Usage:
        controller = CS2RemoteConsoleController(
            cs2_remote_console_path="/path/to/CS2RemoteConsole-client.exe",
            log_callback=lambda msg: print(msg)
        )
        controller.connect()
        controller.send_command("map_workshop addon_name map_name")
        controller.send_command("buildcubemaps")
        controller.disconnect()
    """

    def __init__(
        self,
        cs2_remote_console_path: str,
        cs2_console_ip: str = "127.0.0.1",
        cs2_console_port: int = 29000,
        log_callback: Optional[Callable[[str], None]] = None,
    ):
        """
        Initialize the controller.
        
        Args:
            cs2_remote_console_path: Full path to CS2RemoteConsole-client.exe
            cs2_console_ip: IP address of CS2 console (default: localhost)
            cs2_console_port: Port of CS2 console (default: 29000)
            log_callback: Optional callback for logging messages
        """
        self.cs2_remote_console_path = cs2_remote_console_path
        self.cs2_console_ip = cs2_console_ip
        self.cs2_console_port = cs2_console_port
        self.log_callback = log_callback or (lambda msg: None)
        
        self.pty = None
        self.connected = False
        self.output_buffer = ""

    @staticmethod
    def _clean_ansi(text: str) -> str:
        """
        Remove ANSI escape sequences from text.
        
        Strips color codes, cursor movements, and other terminal control sequences
        that are generated by the TUI application.
        
        Args:
            text: Raw text with ANSI codes
            
        Returns:
            Clean text without ANSI codes
        """
        return ANSI_ESCAPE.sub('', text)

    def _log(self, message: str):
        """Log a message via callback"""
        self.log_callback(message)

    def is_alive(self) -> bool:
        """
        Check if the PTY is still alive and responsive.
        
        Returns:
            True if PTY is alive, False otherwise
        """
        if not self.pty:
            return False
        
        try:
            # Check if the PTY process is still running
            return self.pty.isalive()
        except Exception:
            return False

    def connect(self, timeout: float = 10.0) -> bool:
        """
        Connect to CS2 via RemoteConsole.
        
        Args:
            timeout: Maximum time to wait for connection (seconds)
            
        Returns:
            True if connected, False otherwise
        """

        if not Path(self.cs2_remote_console_path).exists():
            self._log(f"ERROR: CS2RemoteConsole not found at {self.cs2_remote_console_path}")
            return False

        try:
            self._log(f"Connecting to CS2 console at {self.cs2_console_ip}:{self.cs2_console_port}...")
            
            # Create PTY with RemoteConsole
            self.pty = winpty.PtyProcess.spawn(
                [self.cs2_remote_console_path],
                cwd=str(Path(self.cs2_remote_console_path).parent),
            )
            
            # Wait for connection prompt/response
            start_time = time.time()
            while time.time() - start_time < timeout:
                if not self.is_alive():
                    self._log("ERROR: RemoteConsole process died during connection")
                    self.connected = False
                    return False
                
                try:
                    output = self.pty.read()
                    if output:
                        # Decode and clean ANSI codes
                        raw_text = output.decode('utf-8', errors='replace')
                        clean_text = self._clean_ansi(raw_text)
                        
                        self.output_buffer += clean_text
                        if clean_text.strip():
                            self._log(f"[RemoteConsole] {clean_text.strip()}")
                        
                        # Check for connection success indicators
                        if "connected" in clean_text.lower() or "ready" in clean_text.lower():
                            self.connected = True
                            self._log("✓ Connected to CS2 RemoteConsole")
                            return True
                except Exception:
                    pass
                
                time.sleep(0.1)
            
            # If we got here, check if PTY is still alive
            if self.is_alive():
                self.connected = True
                self._log("✓ RemoteConsole PTY established (assuming connected)")
                return True
            else:
                self._log("ERROR: RemoteConsole PTY closed unexpectedly")
                self.connected = False
                return False
            
        except Exception as e:
            self._log(f"ERROR: Failed to connect: {e}")
            return False


    def send_command(self, command: str, wait_time: float = 2.0) -> str:
        """
        Send a command to CS2 via RemoteConsole.
        
        Args:
            command: Command to send (e.g., "map_workshop addon map")
            wait_time: Time to wait for response (seconds)
            
        Returns:
            Output from the command (ANSI codes stripped)
        """
        if not self.connected or not self.pty:
            self._log(f"ERROR: Not connected to RemoteConsole")
            return ""
        
        # Check if PTY is still alive before sending
        if not self.is_alive():
            self._log(f"ERROR: RemoteConsole PTY is not alive (process may have terminated)")
            self.connected = False
            return ""

        try:
            self._log(f"Sending: {command}")
            
            # Send command with CRLF (Windows console expects this)
            self.pty.write(f"{command}\r\n")
            
            # Read response
            response = ""
            start_time = time.time()
            while time.time() - start_time < wait_time:
                if not self.is_alive():
                    self._log("WARNING: RemoteConsole PTY closed during command execution")
                    self.connected = False
                    break
                
                try:
                    output = self.pty.read()
                    if output:
                        # Decode and clean ANSI codes
                        raw_text = output.decode('utf-8', errors='replace')
                        clean_text = self._clean_ansi(raw_text)
                        
                        response += clean_text
                        if clean_text.strip():
                            self._log(f"[Response] {clean_text.strip()}")
                except Exception:
                    pass
                
                time.sleep(0.05)
            
            return response
            
        except Exception as e:
            error_msg = str(e)
            if "pty is closed" in error_msg.lower() or "closed" in error_msg.lower():
                self._log(f"ERROR: RemoteConsole PTY closed unexpectedly")
                self.connected = False
            else:
                self._log(f"ERROR: Failed to send command: {e}")
            return ""


    def send_command_and_wait_for_marker(
        self,
        command: str,
        marker: str,
        timeout: float = 30.0,
    ) -> bool:
        """
        Send a command and wait for a specific output marker (e.g., "cubemaps done").
        
        Args:
            command: Command to send
            marker: Text to wait for in output
            timeout: Maximum time to wait (seconds)
            
        Returns:
            True if marker found, False if timeout
        """
        if not self.connected or not self.pty:
            self._log(f"ERROR: Not connected to RemoteConsole")
            return False
        
        # Check if PTY is still alive before sending
        if not self.is_alive():
            self._log(f"ERROR: RemoteConsole PTY is not alive")
            self.connected = False
            return False

        try:
            self._log(f"Sending: {command} (waiting for '{marker}')")
            
            # Send command
            self.pty.write(f"{command}\r\n")
            
            # Wait for marker
            start_time = time.time()
            accumulated = ""
            while time.time() - start_time < timeout:
                if not self.is_alive():
                    self._log("WARNING: RemoteConsole PTY closed while waiting for marker")
                    self.connected = False
                    return False
                
                try:
                    output = self.pty.read()
                    if output:
                        # Decode and clean ANSI codes
                        raw_text = output.decode('utf-8', errors='replace')
                        clean_text = self._clean_ansi(raw_text)
                        
                        accumulated += clean_text
                        if clean_text.strip():
                            self._log(f"[Response] {clean_text.strip()}")
                        
                        # Check for marker (case-insensitive)
                        if marker.lower() in accumulated.lower():
                            self._log(f"✓ Found marker: {marker}")
                            return True
                except Exception:
                    pass
                
                time.sleep(0.1)
            
            self._log(f"⚠ Timeout waiting for marker: {marker}")
            return False
            
        except Exception as e:
            error_msg = str(e)
            if "pty is closed" in error_msg.lower() or "closed" in error_msg.lower():
                self._log(f"ERROR: RemoteConsole PTY closed unexpectedly")
                self.connected = False
            else:
                self._log(f"ERROR: Failed to send command: {e}")
            return False


    def disconnect(self):
        """Disconnect from CS2 RemoteConsole"""
        try:
            if self.pty:
                self._log("Disconnecting from RemoteConsole...")
                
                # Only try to send quit if PTY is still alive
                if self.is_alive():
                    try:
                        self.pty.write("quit\r\n")
                        time.sleep(0.5)
                    except Exception as e:
                        self._log(f"Note: Could not send quit command: {e}")
                
                # Terminate the PTY process
                try:
                    if self.is_alive():
                        self.pty.terminate(force=True)
                except Exception as e:
                    self._log(f"Note: PTY already terminated: {e}")
                
                self.pty = None
            
            self.connected = False
            self._log("✓ Disconnected")
            
        except Exception as e:
            # Don't report "Pty is closed" as an error during disconnect
            error_msg = str(e)
            if "pty is closed" not in error_msg.lower():
                self._log(f"Warning: Error during disconnect: {e}")
            self.connected = False
            self.pty = None

    def __enter__(self):
        """Context manager entry"""
        self.connect()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.disconnect()
